<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Slot Deutsch</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="style.css">
</head>
<body>

<header>
  <div class="credits-top">
    <span>Created by Ruslan Lomaka</span>
    <span style="opacity:.55;">|</span>
    <a href="https://www.linkedin.com/in/ruslan-lomaka/" target="_blank" rel="noopener">LinkedIn</a>
    <span style="opacity:.55;">|</span>
    <a href="https://github.com/RuslanLomaka/DerDieDasDrill" target="_blank" rel="noopener">GitHub</a>
  </div>

  <div class="header-row">
    <h2 class="app-title" style="color:var(--accent); font-size: 20px;">
      Slot <span style="font-weight: 300;">Deutsch</span>
    </h2>

    <div class="controls-top">
      <button id="repeatToggle" class="chip review-chip" type="button" aria-pressed="false">
        <span id="repeatLabel">Noch</span>
        <span id="listCount" class="pill-count" aria-label="Word count">0</span>
      </button>
      <div class="level-chips" id="levelChips" aria-label="Levels">
        <button id="langBtn" class="lang-toggle" type="button" aria-label="Language">ðŸ‡©ðŸ‡ª</button>
        <button class="chip active" type="button" data-level="A1">A1</button>
        <button class="chip" type="button" data-level="A2">A2</button>
        <button class="chip" type="button" data-level="B1">B1</button>
        <button class="chip" type="button" data-level="B2">B2</button>
        <button class="chip" type="button" data-level="C1">C1</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="game-hud">
    <div class="stat-item">
      <span class="label" id="labelStreak">Streak</span>
      <span class="value" id="streak" style="color:var(--accent)">0</span>
    </div>
    <div class="stat-item">
      <span class="label" id="labelScore">Score</span>
      <span class="value">
        <span id="scoreOk" style="color:var(--ok)">0</span> : <span id="scoreBad" style="color:var(--bad)">0</span>
      </span>
    </div>
    <div class="stat-item">
      <span class="label" id="labelWords">Words</span>
      <button class="value words-trigger" id="levelCount" type="button" aria-label="Word list" style="color: var(--muted)">0</button>
    </div>
  </div>

  <div class="search-panel">
    <input id="searchInput" class="search-input" type="text" inputmode="search" autocomplete="off" placeholder="Search word">
    <div id="searchResults" class="search-results" role="listbox" aria-label="Search results"></div>
  </div>
  <div id="notice" class="notice" aria-live="polite"></div>
  <div id="wordModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-card" role="document">
      <div class="modal-header">
        <h3 class="modal-title">Words</h3>
        <button id="modalClose" class="modal-close" type="button" aria-label="Close">âœ•</button>
      </div>
      <div id="modalList" class="modal-list" role="list"></div>
    </div>
  </div>
  <div id="infoModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-card modal-info" role="document">
      <div class="modal-body">
        <div id="infoWord" class="info-word"></div>
        <div id="infoPlural" class="info-plural"></div>
      </div>
      <div class="modal-footer">
        <button id="infoOk" class="pill" type="button">OK</button>
      </div>
    </div>
  </div>
  <div id="masteredModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-card modal-mastered" role="document">
      <div class="modal-body">
        <div id="masteredTitle" class="mastered-title"></div>
        <div id="masteredText" class="mastered-text"></div>
        <div class="modal-footer">
          <button id="masteredOk" class="pill" type="button">OK</button>
        </div>
      </div>
    </div>
  </div>
  <div id="multiModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal-card modal-mastered" role="document">
      <div class="modal-body">
        <div id="multiTitle" class="mastered-title"></div>
        <div id="multiText" class="mastered-text"></div>
        <div class="modal-footer">
          <button id="multiOk" class="pill" type="button">OK</button>
        </div>
      </div>
    </div>
  </div>

  <div class="stage-wrapper">
    <div class="stage" id="stage">
      <div id="reel" class="reel-container"></div>
    </div>
  </div>

  <div class="controls-area">
    <button class="btn der" onclick="handleChoice('der')">der</button>
    <button class="btn die" onclick="handleChoice('die')">die</button>
    <button class="btn das" onclick="handleChoice('das')">das</button>
  </div>
</main>

<script src="words.js"></script>
<script>
// --- GAME LOGIC ---
let activeWords = [];
let basePool = [];
let currentIndex = 0;
let stats = { ok: 0, bad: 0, streak: 0 };
let isLock = false;
let lockSince = 0;
let wrongLockedKey = null;
let activeUnit = null;
let prevUnit = null;
let noticeTimer = null;

const STORAGE_KEY = "ddd_progress_v1";
const PROGRESS_DEFAULT = {
  levelPrefs: ["A1"],
  savedLevels: ["A1"],
  repeatMode: false,
  lang: "de",
  stats: {},
  totals: { ok: 0, bad: 0 },
  maxStreak: 0,
  achievements: {}
};

function safeParseJSON(text, fallback) {
  try { return JSON.parse(text); } catch (_) { return fallback; }
}

function loadProgress() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return { ...PROGRESS_DEFAULT };
  const data = safeParseJSON(raw, {});
  return {
    ...PROGRESS_DEFAULT,
    ...data,
    stats: data.stats || {},
    totals: data.totals || { ok: 0, bad: 0 },
    achievements: data.achievements || {}
  };
}

function saveProgress() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  } catch (_) {
    // No-op: storage may be unavailable.
  }
}

function getWordKey(item) {
  if (item.id) return item.id;
  const label = getArticleLabel(item);
  return `${item.w}|${label}`;
}

const progress = loadProgress();

function getCorrectArticle(item) {
  return item.correctArticle || item.a || "";
}

function getAllowedArticles(item) {
  return Array.isArray(item.allowedArticles) ? item.allowedArticles : null;
}

function getArticleLabel(item) {
  const allowed = getAllowedArticles(item);
  if (allowed && allowed.length) return allowed.join("/");
  return getCorrectArticle(item);
}

function getGermanHint(item) {
  return item.h?.de ? ` (${item.h.de})` : "";
}

function getGermanWord(item) {
  return `${item.w}${getGermanHint(item)}`;
}

function getTranslationWithHint(item, lang) {
  if (lang === "de") return "";
  const base = item.t?.[lang] || "";
  if (!base) return "";
  const hint = item.h?.[lang];
  return hint ? `${base} (${hint})` : base;
}

function getCurrentActiveData() {
  if (activeWords.length === 0) return null;
  const idx = (currentIndex - 1 + activeWords.length) % activeWords.length;
  return activeWords[idx];
}

/* =========================
   UI TRANSLATIONS
   ========================= */
const ui = {
  de: {
    streak: "Serie",
    score: "Punkte",
    words: "Worter",
    redo: "Fehler",
    plural: "Plural",
    pluralNone: "Kein Plural moeglich",
    mastered: "Gelernt",
    masteredHint: "Aus dem Wiederholen entfernt. Merke dir den Artikel.",
    multiTitle: "Mehrere Artikel",
    multiLine1: "Dieses Wort hat mehr als einen richtigen Artikel.",
    multiLine2: "Erlaubt: {articles}",
    reviewTitle: "Review",
    reviewHint: "5 richtige in Folge fuer ein Wort, dann verschwindet es aus der Liste."
  },
  en: {
    streak: "Streak",
    score: "Score",
    words: "Words",
    redo: "Review",
    plural: "Plural",
    pluralNone: "No plural form",
    mastered: "Mastered",
    masteredHint: "Removed from redo. Remember the article.",
    multiTitle: "Multiple articles",
    multiLine1: "This word accepts more than one article.",
    multiLine2: "Accepted: {articles}",
    reviewTitle: "Review",
    reviewHint: "Get 5 correct in a row on a word to remove it from review."
  },
  uk: {
    streak: "Ð¡ÐµÑ€Ñ–Ñ",
    score: "Ð Ð°Ñ…ÑƒÐ½Ð¾Ðº",
    words: "Ð¡Ð»Ñ–Ð²",
    redo: "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€",
    plural: "ÐœÐ½Ð¾Ð¶Ð¸Ð½Ð°",
    pluralNone: "ÐÐµÐ¼Ð°Ñ” Ñ„Ð¾Ñ€Ð¼Ð¸ Ð¼Ð½Ð¾Ð¶Ð¸Ð½Ð¸",
    mastered: "Ð’Ð¸Ð²Ñ‡ÐµÐ½Ð¾",
    masteredHint: "Ð’Ð¸Ð»ÑƒÑ‡ÐµÐ½Ð¾ Ð· Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ÐµÐ½Ð½Ñ. Ð—Ð°Ð¿Ð°Ð¼'ÑÑ‚Ð°Ð¹ Ð°Ñ€Ñ‚Ð¸ÐºÐ»ÑŒ.",
    multiTitle: "ÐšÑ–Ð»ÑŒÐºÐ° Ð°Ñ€Ñ‚Ð¸ÐºÐ»Ñ–Ð²",
    multiLine1: "Ð¦Ðµ ÑÐ»Ð¾Ð²Ð¾ Ð¼Ð°Ñ” Ð±Ñ–Ð»ÑŒÑˆÐµ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð°Ñ€Ñ‚Ð¸ÐºÐ»Ñ.",
    multiLine2: "Ð”Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ñ–: {articles}",
    reviewTitle: "ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€",
    reviewHint: "5 Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ñ… Ð¿Ñ–Ð´Ñ€ÑÐ´ Ð´Ð»Ñ ÑÐ»Ð¾Ð²Ð° â€” Ñ– Ð¹Ð¾Ð³Ð¾ Ð±ÑƒÐ´Ðµ Ð¿Ñ€Ð¸Ð±Ñ€Ð°Ð½Ð¾ Ð·Ñ– ÑÐ¿Ð¸ÑÐºÑƒ."
  }
};

/* =========================
   LANGUAGE TOGGLE
   ========================= */
const langBtn = document.getElementById('langBtn');
const LANGS = ["de", "en", "uk"];
const LANG_FLAG = { de: "ðŸ‡©ðŸ‡ª", en: "ðŸ‡¬ðŸ‡§", uk: "ðŸ‡ºðŸ‡¦" };
let currentLangIndex = 0;

function currentLang() { return LANGS[currentLangIndex]; }

function setLang(lang, options = {}) {
  const { save = true } = options;
  const idx = LANGS.indexOf(lang);
  currentLangIndex = idx >= 0 ? idx : 0;
  const active = currentLang();
  langBtn.textContent = LANG_FLAG[active] || "ðŸ³ï¸";
  langBtn.classList.toggle('lang-de', active === 'de');
  langBtn.classList.toggle('lang-en', active === 'en');
  langBtn.classList.toggle('lang-uk', active === 'uk');
  applyUiLang(active);
  refreshActiveTranslation();
  if (save) {
    progress.lang = active;
    saveProgress();
  }
}

function bumpLang() {
  const next = (currentLangIndex + 1) % LANGS.length;
  setLang(LANGS[next]);
  langBtn.classList.remove('is-dim');
}

langBtn.addEventListener('click', bumpLang);
langBtn.addEventListener('touchstart', () => langBtn.classList.remove('is-dim'), { passive: true });

function applyUiLang(lang) {
  const t = ui[lang] || ui.de;
  document.getElementById('labelStreak').textContent = t.streak;
  document.getElementById('labelScore').textContent  = t.score;
  document.getElementById('labelWords').textContent  = t.words;
  if (repeatLabel) repeatLabel.textContent = t.redo;
  if (wordModal) {
    const title = wordModal.querySelector('.modal-title');
    if (title) title.textContent = t.words;
  }
}

const noticeEl = document.getElementById('notice');
function showNotice(message) {
  if (!noticeEl) return;
  if (noticeTimer) clearTimeout(noticeTimer);
  noticeEl.textContent = message;
  noticeEl.classList.add('is-visible');
  noticeTimer = setTimeout(() => {
    noticeEl.classList.remove('is-visible');
  }, 2400);
}

function showMasteredNotice(item) {
  const t = ui[currentLang()] || ui.de;
  if (!masteredModal || !masteredTitle || !masteredText) return;
  masteredTitle.textContent = t.mastered;
  masteredText.textContent = `${getArticleLabel(item)} ${getGermanWord(item)}. ${t.masteredHint}`;
  masteredModal.classList.add('is-visible');
  masteredModal.setAttribute('aria-hidden', 'false');
}

function closeMasteredModal() {
  if (!masteredModal) return;
  masteredModal.classList.remove('is-visible');
  masteredModal.setAttribute('aria-hidden', 'true');
}

function showMultiArticleModal(item) {
  const t = ui[currentLang()] || ui.de;
  if (!multiModal || !multiTitle || !multiText) return;
  const allowed = getAllowedArticles(item) || [];
  const articles = allowed.map(a => a.toUpperCase()).join(" / ");
  multiTitle.textContent = t.multiTitle;
  multiText.textContent = `${t.multiLine1} ${t.multiLine2.replace('{articles}', articles)}`;
  multiModal.classList.add('is-visible');
  multiModal.setAttribute('aria-hidden', 'false');
}

function closeMultiModal() {
  if (!multiModal) return;
  multiModal.classList.remove('is-visible');
  multiModal.setAttribute('aria-hidden', 'true');
}

/* =========================
   LEVEL CHIPS (multi-select)
   ========================= */
const levelChips = document.getElementById('levelChips');
const chipButtons = [...levelChips.querySelectorAll('.chip')];
const repeatToggle = document.getElementById('repeatToggle');
const repeatLabel = document.getElementById('repeatLabel');
const listCountEl = document.getElementById('listCount');
const wordModal = document.getElementById('wordModal');
const modalList = document.getElementById('modalList');
const modalClose = document.getElementById('modalClose');
const levelCountBtn = document.getElementById('levelCount');
const infoModal = document.getElementById('infoModal');
const infoOk = document.getElementById('infoOk');
const infoWord = document.getElementById('infoWord');
const infoPlural = document.getElementById('infoPlural');
const masteredModal = document.getElementById('masteredModal');
const masteredTitle = document.getElementById('masteredTitle');
const masteredText = document.getElementById('masteredText');
const masteredOk = document.getElementById('masteredOk');
const multiModal = document.getElementById('multiModal');
const multiTitle = document.getElementById('multiTitle');
const multiText = document.getElementById('multiText');
const multiOk = document.getElementById('multiOk');

// UPDATED: added C1
const LEVELS = ["A1", "A2", "B1", "B2", "C1"];
function normalizeLevels(levels, fallback = ["A1"]) {
  const list = Array.isArray(levels) ? levels : [];
  const valid = list.filter(l => LEVELS.includes(l));
  return valid.length ? [...new Set(valid)] : fallback;
}
let selectedLevels = new Set(normalizeLevels(progress.levelPrefs));
let savedLevels = new Set(normalizeLevels(progress.savedLevels, [...selectedLevels]));
let repeatMode = progress.repeatMode === true;
if (!repeatMode) {
  progress.levelPrefs = [...selectedLevels];
  progress.savedLevels = [...savedLevels];
  saveProgress();
}

function setChipActive(level, isActive) {
  const btn = chipButtons.find(b => b.dataset.level === level);
  if (!btn) return;
  btn.classList.toggle('active', isActive);
}

function syncChipsToSelection() {
  LEVELS.forEach(l => setChipActive(l, selectedLevels.has(l)));
}

function isMastered(item) {
  const key = getWordKey(item);
  return Boolean(progress.stats[key]?.mastered);
}

function hasMistake(item) {
  const key = getWordKey(item);
  return Boolean(progress.stats[key]?.wrongTotal);
}

function buildBasePool() {
  if (repeatMode) {
    return rawData.filter(item => hasMistake(item) && !isMastered(item));
  }
  return rawData.filter(item => selectedLevels.has(item.l) && !isMastered(item));
}

function updateWordCount(count) {
  document.getElementById('levelCount').innerText = count;
  if (listCountEl) {
    const mistakeCount = rawData.filter(item => hasMistake(item) && !isMastered(item)).length;
    listCountEl.textContent = mistakeCount;
    updateReviewVisual(mistakeCount);
  }
}

function updateReviewVisual(count) {
  if (!repeatToggle) return;
  const t = Math.min(count / 20, 1);
  const start = { r: 54, g: 198, b: 137 };
  const end = { r: 255, g: 100, b: 112 };
  const mix = (a, b) => Math.round(a + (b - a) * t);
  const r = mix(start.r, end.r);
  const g = mix(start.g, end.g);
  const b = mix(start.b, end.b);
  const color = `rgb(${r}, ${g}, ${b})`;
  const bg = `rgba(${r}, ${g}, ${b}, 0.22)`;
  repeatToggle.style.setProperty('--review-color', color);
  repeatToggle.style.setProperty('--review-bg', bg);
  repeatToggle.classList.toggle('review-hot', count >= 20);
}

function renderWordList() {
  if (!modalList) return;
  const lang = currentLang();
  const items = [...basePool].sort((a, b) => a.w.localeCompare(b.w, 'de'));
  modalList.innerHTML = '';
  if (items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'modal-empty';
    empty.textContent = 'No words.';
    modalList.appendChild(empty);
    return;
  }
  items.forEach(item => {
    const row = document.createElement('div');
    row.className = 'modal-row';
    const translation = getTranslationWithHint(item, lang);
    row.innerHTML =
      `<div class="modal-word"><span class="modal-article">${getArticleLabel(item)}</span>${getGermanWord(item)}</div>` +
      `<div class="modal-meta">` +
        `<span class="modal-level">${item.l}</span>` +
        `<span class="modal-translation">${translation}</span>` +
      `</div>`;
    modalList.appendChild(row);
  });
}

function openWordModal() {
  renderWordList();
  wordModal.classList.add('is-visible');
  wordModal.setAttribute('aria-hidden', 'false');
}

function closeWordModal() {
  wordModal.classList.remove('is-visible');
  wordModal.setAttribute('aria-hidden', 'true');
}

function openInfoModal(item) {
  if (!infoModal || !infoWord || !infoPlural) return;
  const t = ui[currentLang()] || ui.de;
  infoWord.textContent = `${getArticleLabel(item)} ${getGermanWord(item)}`;
  if (item.p && String(item.p).trim()) {
    infoPlural.textContent = `${t.plural}: ${item.p}`;
    infoPlural.style.display = 'block';
  } else {
    infoPlural.textContent = t.pluralNone;
    infoPlural.style.display = 'block';
  }
  infoModal.classList.add('is-visible');
  infoModal.setAttribute('aria-hidden', 'false');
}

function closeInfoModal() {
  infoModal.classList.remove('is-visible');
  infoModal.setAttribute('aria-hidden', 'true');
}

function setRepeatMode(enabled, options = {}) {
  const { preserveSavedLevels = false, skipSave = false } = options;
  repeatMode = enabled;
  progress.repeatMode = enabled;
  repeatToggle.classList.toggle('active', enabled);
  repeatToggle.setAttribute('aria-pressed', enabled ? "true" : "false");
  levelChips.classList.toggle('is-disabled', enabled);

  if (enabled) {
    const t = ui[currentLang()] || ui.de;
    if (multiModal && multiTitle && multiText) {
      multiTitle.textContent = t.reviewTitle || t.multiTitle;
      multiText.textContent = t.reviewHint;
      multiModal.classList.add('is-visible');
      multiModal.setAttribute('aria-hidden', 'false');
    }
    if (!preserveSavedLevels) {
      savedLevels = new Set(selectedLevels);
      progress.savedLevels = [...savedLevels];
    }
    selectedLevels = new Set();
    LEVELS.forEach(l => setChipActive(l, false));
    rebuildWordPool();
    if (activeWords.length === 0) {
      showNotice("No repeat words yet.");
    }
  } else {
    const restore = normalizeLevels([...savedLevels]);
    selectedLevels = new Set(restore);
    progress.levelPrefs = [...selectedLevels];
    progress.savedLevels = [...savedLevels];
    syncChipsToSelection();
    rebuildWordPool();
  }

  if (!skipSave) saveProgress();
}

function rebuildWordPool() {
  if (!repeatMode && selectedLevels.size === 0) {
    selectedLevels.add("A1");
    setChipActive("A1", true);
    progress.levelPrefs = [...selectedLevels];
    savedLevels = new Set(selectedLevels);
    progress.savedLevels = [...savedLevels];
    saveProgress();
  }

  basePool = buildBasePool();
  if (!repeatMode && basePool.length === 0) {
    basePool = rawData.filter(item => selectedLevels.has(item.l));
  }
  activeWords = basePool.slice();
  updateWordCount(basePool.length);

  shuffle(activeWords);
  currentIndex = 0;

  document.getElementById('reel').innerHTML = '';
  prevUnit = null;
  activeUnit = null;

  if (activeWords.length === 0) {
    refreshActiveTranslation();
    langBtn.classList.remove('is-dim');
    return;
  }

  const first = spawnWord("pos-active");
  if (first) {
    currentIndex++;
    spawnWord("pos-next");
  }

  langBtn.classList.remove('is-dim');
  refreshActiveTranslation();
}

function onChipClick(level) {
  if (repeatMode) return;
  if (selectedLevels.has(level)) {
    selectedLevels.delete(level);
    setChipActive(level, false);
  } else {
    selectedLevels.add(level);
    setChipActive(level, true);
  }

  progress.levelPrefs = [...selectedLevels];
  savedLevels = new Set(selectedLevels);
  progress.savedLevels = [...savedLevels];
  saveProgress();
  rebuildWordPool();
}

levelChips.addEventListener('click', (e) => {
  const btn = e.target.closest('.chip');
  if (!btn) return;
  onChipClick(btn.dataset.level);
});

repeatToggle.addEventListener('click', () => setRepeatMode(!repeatMode));

/* =========================
   TRANSLATION SUBTITLE
   ========================= */
function ensureWordStats(item) {
  const key = getWordKey(item);
  if (!progress.stats[key]) {
    progress.stats[key] = {
      wrongStreak: 0,
      rightStreak: 0,
      wrongTotal: 0,
      rightTotal: 0,
      mastered: false,
      lastWarnedStreak: 0,
      lastAttempts: []
    };
  } else if (!Array.isArray(progress.stats[key].lastAttempts)) {
    progress.stats[key].lastAttempts = [];
  }
  return progress.stats[key];
}

function renderAttemptBar(unit, item) {
  if (!unit) return;
  const content = unit.querySelector('.slot-content');
  if (!content) return;

  const existing = unit.querySelector('.attempt-bar');
  if (existing) existing.remove();
  if (!repeatMode) return;

  const wordStats = ensureWordStats(item);
  const history = Array.isArray(wordStats.lastAttempts)
    ? wordStats.lastAttempts.slice(-5)
    : [];

  const bar = document.createElement('div');
  bar.className = 'attempt-bar';

  const offset = 5 - history.length;
  for (let i = 0; i < 5; i++) {
    const seg = document.createElement('span');
    seg.className = 'attempt-seg';
    if (i >= offset) {
      const isCorrect = history[i - offset] === true;
      seg.classList.add(isCorrect ? 'is-correct' : 'is-wrong');
    }
    bar.appendChild(seg);
  }

  content.prepend(bar);
}

function updateAchievements() {
  const unlocked = progress.achievements;
  if (progress.maxStreak >= 10) unlocked.streak10 = true;
  if (progress.totals.ok >= 100) unlocked.correct100 = true;
  const masteredCount = Object.values(progress.stats).filter(s => s.mastered).length;
  if (masteredCount >= 10) unlocked.mastered10 = true;
}

function updateProgressOnAnswer(item, isRight) {
  const wordStats = ensureWordStats(item);
  const wasMastered = Boolean(wordStats.mastered);
  if (isRight) {
    wordStats.rightTotal++;
    wordStats.rightStreak++;
    wordStats.wrongStreak = 0;
    wordStats.lastWarnedStreak = 0;
  } else {
    wordStats.wrongTotal++;
    wordStats.wrongStreak++;
    wordStats.rightStreak = 0;
  }

  if (!isRight && wordStats.wrongStreak === 5 && wordStats.lastWarnedStreak !== 5) {
    showNotice(`Be more patient: ${getArticleLabel(item)} ${getGermanWord(item)}`);
    wordStats.lastWarnedStreak = 5;
  }

  if (isRight && wordStats.rightStreak === 5) {
    wordStats.mastered = true;
    if (!wasMastered) showMasteredNotice(item);
  }

  wordStats.lastAttempts.push(isRight);
  if (wordStats.lastAttempts.length > 5) {
    wordStats.lastAttempts.splice(0, wordStats.lastAttempts.length - 5);
  }

  if (isRight) progress.totals.ok++;
  else progress.totals.bad++;

  if (stats.streak > progress.maxStreak) {
    progress.maxStreak = stats.streak;
  }

  updateAchievements();
  saveProgress();

  if (repeatMode && activeUnit) {
    const activeData = getCurrentActiveData();
    if (activeData && getWordKey(activeData) === getWordKey(item)) {
      renderAttemptBar(activeUnit, activeData);
    }
  }
}

function getTranslationFor(item, lang) {
  if (!item) return "";
  return getTranslationWithHint(item, lang);
}

function refreshActiveTranslation() {
  const lang = currentLang();
  if (!activeUnit) return;
  if (activeWords.length === 0) return;

  const data = activeWords[(currentIndex - 1) % activeWords.length];
  const sub = activeUnit.querySelector('.sub-translation');
  if (!sub) return;

  const txt = getTranslationFor(data, lang);
  sub.textContent = txt ? txt : "";
  sub.style.display = (txt && lang !== "de") ? "block" : "none";
}

function refitWord(unit) {
  if (!unit) return;
  const row = unit.querySelector('.caption-row');
  if (!row) return;
  unit.style.setProperty('--word-scale', '1');
  const available = Math.max(0, unit.clientWidth - 36);
  if (available <= 0) return;
  let width = row.scrollWidth;
  if (unit.classList.contains('resolved')) {
    const articleEl = unit.querySelector('.article-reveal');
    if (articleEl) {
      const styles = getComputedStyle(articleEl);
      width += parseFloat(styles.marginRight || '0');
    }
  }
  if (width > available) {
    const minScale = unit.classList.contains('resolved') ? 0.37 : 0.72;
    const scale = Math.max(minScale, available / width);
    unit.style.setProperty('--word-scale', scale.toFixed(3));
  }
}

function refitVisibleWords() {
  const units = document.querySelectorAll('.slot-unit');
  units.forEach(refitWord);
}

function ensureInitialPool() {
  if (repeatMode || activeWords.length > 0) return;
  if (selectedLevels.size === 0) {
    selectedLevels = new Set(normalizeLevels(progress.savedLevels));
  }
  progress.levelPrefs = [...selectedLevels];
  savedLevels = new Set(selectedLevels);
  progress.savedLevels = [...savedLevels];
  syncChipsToSelection();
  rebuildWordPool();
  if (activeWords.length === 0) {
    selectedLevels = new Set(LEVELS);
    savedLevels = new Set(selectedLevels);
    progress.levelPrefs = [...selectedLevels];
    progress.savedLevels = [...savedLevels];
    syncChipsToSelection();
    rebuildWordPool();
  }
}

/* =========================
   SLOT POSITIONING (never clip prev)
   ========================= */
function updateSlotPositions() {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const stageH = stage.clientHeight;
  const slotH = 140;

  const yActive = Math.round((stageH - slotH) / 2);
  const yNext = Math.max(2, yActive - 148);
  const yPrev = Math.min(stageH - slotH - 2, yActive + 148);
  const yExit = stageH + 40;

  document.documentElement.style.setProperty('--y-next',   `${yNext}px`);
  document.documentElement.style.setProperty('--y-active', `${yActive}px`);
  document.documentElement.style.setProperty('--y-prev',   `${yPrev}px`);
  document.documentElement.style.setProperty('--y-exit',   `${yExit}px`);

  refitVisibleWords();
}

window.addEventListener('resize', updateSlotPositions);
window.addEventListener('orientationchange', () => setTimeout(updateSlotPositions, 80));

/* =========================
   CORE GAME
   ========================= */
function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}

function findNextPlayableIndex(startIndex) {
  if (activeWords.length === 0) return -1;
  for (let i = 0; i < activeWords.length; i++) {
    const idx = (startIndex + i) % activeWords.length;
    if (!isMastered(activeWords[idx])) return idx;
  }
  return repeatMode ? -1 : (startIndex % activeWords.length);
}

function spawnWord(startPos, options = {}) {
  const { forceIndex = null } = options;
  const reel = document.getElementById('reel');
  const spawnIndex = forceIndex === null ? findNextPlayableIndex(currentIndex) : forceIndex;
  if (spawnIndex === -1) return null;
  currentIndex = spawnIndex;
  const data = activeWords[currentIndex % activeWords.length];

  const unit = document.createElement('div');
  unit.className = `slot-unit ${startPos}`;
  unit.dataset.key = getWordKey(data);
  unit.innerHTML =
    `<div class="slot-content">` +
      `<div class="caption-row">` +
        `<span class="article-reveal">${getAllowedArticles(data) ? "" : getCorrectArticle(data)}</span>` +
        `<span class="word-span">${getGermanWord(data)}</span>` +
      `</div>` +
      `<div class="sub-translation"></div>` +
    `</div>`;

  reel.appendChild(unit);
  refitWord(unit);

  if (repeatMode) renderAttemptBar(unit, data);

  if (startPos === "pos-active") {
    activeUnit = unit;
    refreshActiveTranslation();
  } else {
    const sub = unit.querySelector('.sub-translation');
    if (sub) sub.style.display = "none";
  }

  return unit;
}

function handleChoice(choice) {
  if (isLock && Date.now() - lockSince > 1800) {
    isLock = false;
  }
  if (activeWords.length === 0) return;
  if (!activeUnit) {
    rebuildWordPool();
    return;
  }
  if (isLock) return;

  langBtn.classList.add('is-dim');

  const currentKey = activeUnit.dataset.key;
  const currentData = currentKey ? WORD_INDEX.get(currentKey) : null;
  if (!currentData) {
    rebuildWordPool();
    return;
  }
  if (wrongLockedKey && wrongLockedKey !== currentKey) {
    wrongLockedKey = null;
  }
  const allowed = getAllowedArticles(currentData);
  const correctArt = getCorrectArticle(currentData);
  const isRight = allowed ? allowed.includes(choice) : choice === correctArt;

  if (!isRight) {
    activeUnit.classList.add('shake-active');
    setTimeout(() => activeUnit.classList.remove('shake-active'), 300);
    if (wrongLockedKey !== currentKey) {
      wrongLockedKey = currentKey;
      stats.bad++;
      stats.streak = 0;
      updateScore();
      updateProgressOnAnswer(currentData, false);
    }
    return;
  }

  isLock = true;
  lockSince = Date.now();
  setTimeout(() => {
    if (isLock && Date.now() - lockSince > 2000) {
      isLock = false;
    }
  }, 2100);
  stats.ok++;
  stats.streak++;
  wrongLockedKey = null;
  updateScore();
  updateProgressOnAnswer(currentData, true);
  if (allowed) {
    showMultiArticleModal(currentData);
  }

  activeUnit.classList.add('resolved');
  const articleEl = activeUnit.querySelector('.article-reveal');
  if (articleEl) articleEl.textContent = choice;
  activeUnit.style.color = `var(--${choice})`;
  activeUnit.offsetWidth;
  refitWord(activeUnit);
  requestAnimationFrame(() => refitWord(activeUnit));

  setTimeout(() => {
    try {
      const nextInLine = document.querySelector('.pos-next');

      if (prevUnit) {
        prevUnit.className = 'slot-unit pos-exit';
        const toDelete = prevUnit;
        setTimeout(() => toDelete.remove(), 700);
      }

      prevUnit = activeUnit;
      prevUnit.className = 'slot-unit pos-prev resolved';

      activeUnit = nextInLine;
      if (activeUnit) activeUnit.className = 'slot-unit pos-active';

      currentIndex++;
      spawnWord("pos-next");

      const activeData = getCurrentActiveData();
      if (activeUnit && activeData && repeatMode) {
        renderAttemptBar(activeUnit, activeData);
      }
      if (activeUnit) refitWord(activeUnit);

      basePool = buildBasePool();
      updateWordCount(basePool.length);

      if (basePool.length === 0) {
        document.getElementById('reel').innerHTML = '';
        prevUnit = null;
        activeUnit = null;
        showNotice("No words left.");
      }

      refreshActiveTranslation();
    } finally {
      isLock = false;
    }
  }, 1400);
}

function updateScore() {
  document.getElementById('scoreOk').innerText = stats.ok;
  document.getElementById('scoreBad').innerText = stats.bad;
  document.getElementById('streak').innerText = stats.streak;
}

const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const WORD_INDEX = new Map(
  rawData
    .filter(item => item && item.w && (item.correctArticle || item.allowedArticles || item.a))
    .map(item => [getWordKey(item), item])
);

function clearSearchResults() {
  searchResults.innerHTML = '';
  searchResults.classList.remove('is-visible');
  document.body.classList.remove('search-open');
}

function renderSearchResults(items) {
  searchResults.innerHTML = '';
  if (items.length === 0) {
    searchResults.classList.remove('is-visible');
    document.body.classList.remove('search-open');
    return;
  }
  const lang = currentLang();

  items.forEach(item => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'search-item';
    btn.dataset.key = getWordKey(item);
    const translation = getTranslationWithHint(item, lang);
    const plural = item.p && String(item.p).trim() ? item.p : '';
    const metaParts = [];
    metaParts.push(item.l);
    if (plural) metaParts.push(`Pl: ${plural}`);
    if (translation) metaParts.push(translation);
    btn.innerHTML =
      `<strong>${getArticleLabel(item)}</strong> ${getGermanWord(item)}` +
      `<span class="hint">${metaParts.join(' â€¢ ')}</span>`;
    searchResults.appendChild(btn);
  });

  searchResults.classList.add('is-visible');
  document.body.classList.add('search-open');
}

function updateSearchResults() {
  const q = searchInput.value.trim().toLowerCase();
  if (!q) {
    clearSearchResults();
    return;
  }
  const matches = [];
  for (const item of rawData) {
    if (item.w.toLowerCase().startsWith(q)) {
      matches.push(item);
      if (matches.length >= 8) break;
    }
  }
  renderSearchResults(matches);
}

function jumpToWord(item) {
  const pool = buildBasePool();
  const key = getWordKey(item);
  const rest = pool.filter(w => getWordKey(w) !== key);
  shuffle(rest);

  basePool = pool;
  activeWords = [item, ...rest];
  updateWordCount(basePool.length);

  currentIndex = 0;
  document.getElementById('reel').innerHTML = '';
  prevUnit = null;
  activeUnit = null;

  const first = spawnWord("pos-active", { forceIndex: 0 });
  if (first) {
    currentIndex++;
    spawnWord("pos-next");
  }

  langBtn.classList.remove('is-dim');
  refreshActiveTranslation();
}

searchInput.addEventListener('input', updateSearchResults);
searchInput.addEventListener('focus', updateSearchResults);
searchInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const first = searchResults.querySelector('.search-item');
    if (first) {
      const item = WORD_INDEX.get(first.dataset.key);
      if (item) jumpToWord(item);
    }
    clearSearchResults();
  }
});

searchResults.addEventListener('click', (e) => {
  const btn = e.target.closest('.search-item');
  if (!btn) return;
  const item = WORD_INDEX.get(btn.dataset.key);
  if (!item) return;
  searchInput.value = item.w;
  clearSearchResults();
  jumpToWord(item);
  openInfoModal(item);
});

document.addEventListener('click', (e) => {
  if (e.target === searchInput || searchResults.contains(e.target)) return;
  clearSearchResults();
});

window.onkeydown = (e) => {
  const tag = document.activeElement?.tagName || "";
  if (tag === "INPUT" || tag === "TEXTAREA") return;
  if (e.key === 'Escape') closeWordModal();
  const key = e.key.toLowerCase();
  if (key === 'a') handleChoice('der');
  if (key === 's') handleChoice('die');
  if (key === 'd') handleChoice('das');
};

levelCountBtn.addEventListener('click', openWordModal);
modalClose.addEventListener('click', closeWordModal);
wordModal.addEventListener('click', (e) => {
  if (e.target === wordModal) closeWordModal();
});
infoOk.addEventListener('click', closeInfoModal);
infoModal.addEventListener('click', (e) => {
  if (e.target === infoModal) closeInfoModal();
});
masteredModal.addEventListener('click', (e) => {
  if (e.target === masteredModal) closeMasteredModal();
});
masteredOk.addEventListener('click', closeMasteredModal);
multiModal.addEventListener('click', (e) => {
  if (e.target === multiModal) closeMultiModal();
});
multiOk.addEventListener('click', closeMultiModal);

setLang(progress.lang || "de", { save: false });
syncChipsToSelection();
if (repeatMode) {
  setRepeatMode(true, { preserveSavedLevels: true, skipSave: true });
  if (basePool.length === 0) {
    setRepeatMode(false, { preserveSavedLevels: true, skipSave: true });
  }
} else {
  rebuildWordPool();
}
ensureInitialPool();
updateSlotPositions();
updateScore();
</script>
</body>
</html>
