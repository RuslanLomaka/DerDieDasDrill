<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Slot Deutsch</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<header>
  <div class="credits-top">
    <span>Created by Ruslan Lomaka</span>
    <span style="opacity:.55;">|</span>
    <a href="https://www.linkedin.com/in/ruslan-lomaka/" target="_blank" rel="noopener">LinkedIn</a>
    <span style="opacity:.55;">|</span>
    <a href="https://github.com/RuslanLomaka/DerDieDasDrill" target="_blank" rel="noopener">GitHub</a>
  </div>

  <div class="header-row">
    <h2 class="app-title" style="color:var(--accent); font-size: 20px;">
      Slot <span style="font-weight: 300;">Deutsch</span>
    </h2>

    <div class="controls-top">
      <button id="repeatToggle" class="pill" type="button" aria-pressed="false">
        <span id="repeatLabel">Noch</span>
        <span id="listCount" class="pill-count" aria-label="Word count">0</span>
      </button>
      <div class="level-chips" id="levelChips" aria-label="Levels">
        <button class="chip active" type="button" data-level="A1">A1</button>
        <button class="chip" type="button" data-level="A2">A2</button>
        <button class="chip" type="button" data-level="B1">B1</button>
        <button class="chip" type="button" data-level="B2">B2</button>
        <button class="chip" type="button" data-level="C1">C1</button>
        <button class="chip" type="button" data-level="ALL">ALL</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="game-hud">
    <div class="stat-item">
      <span class="label" id="labelStreak">Streak</span>
      <span class="value" id="streak" style="color:var(--accent)">0</span>
    </div>
    <div class="stat-item">
      <span class="label" id="labelScore">Score</span>
      <span class="value">
        <span id="scoreOk" style="color:var(--ok)">0</span> : <span id="scoreBad" style="color:var(--bad)">0</span>
      </span>
    </div>
    <div class="stat-item">
      <span class="label" id="labelWords">Words</span>
      <span class="value" id="levelCount" style="color: var(--muted)">0</span>
    </div>
  </div>

  <div class="search-panel">
    <input id="searchInput" class="search-input" type="text" inputmode="search" autocomplete="off" placeholder="Search word">
    <div id="searchResults" class="search-results" role="listbox" aria-label="Search results"></div>
  </div>
  <div id="notice" class="notice" aria-live="polite"></div>

  <div class="stage-wrapper">
    <div class="stage" id="stage">
      <button id="langBtn" class="lang-toggle" type="button" aria-label="Language">ðŸ‡©ðŸ‡ª</button>
      <div id="reel" class="reel-container"></div>
    </div>
  </div>

  <div class="controls-area">
    <button class="btn der" onclick="handleChoice('der')">der</button>
    <button class="btn die" onclick="handleChoice('die')">die</button>
    <button class="btn das" onclick="handleChoice('das')">das</button>
  </div>
</main>

<script src="words.js"></script>
<script>
// --- GAME LOGIC ---
let activeWords = [];
let basePool = [];
let currentIndex = 0;
let stats = { ok: 0, bad: 0, streak: 0 };
let isLock = false;
let activeUnit = null;
let prevUnit = null;
let noticeTimer = null;

const STORAGE_KEY = "ddd_progress_v1";
const PROGRESS_DEFAULT = {
  levelPrefs: ["A1"],
  savedLevels: ["A1"],
  repeatMode: false,
  stats: {},
  totals: { ok: 0, bad: 0 },
  maxStreak: 0,
  achievements: {}
};

function safeParseJSON(text, fallback) {
  try { return JSON.parse(text); } catch (_) { return fallback; }
}

function loadProgress() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return { ...PROGRESS_DEFAULT };
  const data = safeParseJSON(raw, {});
  return {
    ...PROGRESS_DEFAULT,
    ...data,
    stats: data.stats || {},
    totals: data.totals || { ok: 0, bad: 0 },
    achievements: data.achievements || {}
  };
}

function saveProgress() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  } catch (_) {
    // No-op: storage may be unavailable.
  }
}

function getWordKey(item) {
  return `${item.w}|${item.a}`;
}

const progress = loadProgress();

/* =========================
   UI TRANSLATIONS
   ========================= */
const ui = {
  de: { streak: "Streak", score: "Score", words: "Words", redo: "Noch" },
  en: { streak: "Streak", score: "Score", words: "Words", redo: "Redo" },
  uk: { streak: "Ð¡ÐµÑ€Ñ–Ñ", score: "Ð Ð°Ñ…ÑƒÐ½Ð¾Ðº", words: "Ð¡Ð»Ñ–Ð²", redo: "Ð·Ð½Ð¾Ð²" }
};

/* =========================
   LANGUAGE TOGGLE
   ========================= */
const langBtn = document.getElementById('langBtn');
const LANGS = ["de", "en", "uk"];
const LANG_FLAG = { de: "ðŸ‡©ðŸ‡ª", en: "ðŸ‡¬ðŸ‡§", uk: "ðŸ‡ºðŸ‡¦" };
let currentLangIndex = 0;

function currentLang() { return LANGS[currentLangIndex]; }

function setLangIndex(idx) {
  currentLangIndex = (idx + LANGS.length) % LANGS.length;
  const lang = currentLang();
  langBtn.textContent = LANG_FLAG[lang] || "ðŸ³ï¸";
  applyUiLang(lang);
  refreshActiveTranslation();
}

function bumpLang() {
  setLangIndex(currentLangIndex + 1);
  langBtn.classList.remove('is-dim');
}

langBtn.addEventListener('click', bumpLang);
langBtn.addEventListener('touchstart', () => langBtn.classList.remove('is-dim'), { passive: true });

function applyUiLang(lang) {
  const t = ui[lang] || ui.de;
  document.getElementById('labelStreak').textContent = t.streak;
  document.getElementById('labelScore').textContent  = t.score;
  document.getElementById('labelWords').textContent  = t.words;
  if (repeatLabel) repeatLabel.textContent = t.redo;
}

const noticeEl = document.getElementById('notice');
function showNotice(message) {
  if (!noticeEl) return;
  if (noticeTimer) clearTimeout(noticeTimer);
  noticeEl.textContent = message;
  noticeEl.classList.add('is-visible');
  noticeTimer = setTimeout(() => {
    noticeEl.classList.remove('is-visible');
  }, 2400);
}

/* =========================
   LEVEL CHIPS (multi-select)
   ========================= */
const levelChips = document.getElementById('levelChips');
const chipButtons = [...levelChips.querySelectorAll('.chip')];
const repeatToggle = document.getElementById('repeatToggle');
const repeatLabel = document.getElementById('repeatLabel');
const listCountEl = document.getElementById('listCount');

// UPDATED: added C1
const LEVELS = ["A1", "A2", "B1", "B2", "C1"];
let selectedLevels = new Set(
  Array.isArray(progress.levelPrefs) && progress.levelPrefs.length
    ? progress.levelPrefs
    : ["A1"]
);
let repeatMode = progress.repeatMode === true;
let savedLevels = Array.isArray(progress.savedLevels) && progress.savedLevels.length
  ? progress.savedLevels
  : [...selectedLevels];

function setChipActive(level, isActive) {
  const btn = chipButtons.find(b => b.dataset.level === level);
  if (!btn) return;
  btn.classList.toggle('active', isActive);
}

function syncChipsToSelection() {
  LEVELS.forEach(l => setChipActive(l, selectedLevels.has(l)));
  updateAllChipState();
}

function updateAllChipState() {
  const allOn = LEVELS.every(l => selectedLevels.has(l));
  setChipActive("ALL", allOn);
}

function isMastered(item) {
  const key = getWordKey(item);
  return Boolean(progress.stats[key]?.mastered);
}

function hasMistake(item) {
  const key = getWordKey(item);
  return Boolean(progress.stats[key]?.wrongTotal);
}

function buildBasePool() {
  if (repeatMode) {
    return rawData.filter(item => hasMistake(item) && !isMastered(item));
  }
  return rawData.filter(item => selectedLevels.has(item.l) && !isMastered(item));
}

function updateWordCount(count) {
  document.getElementById('levelCount').innerText = count;
  if (listCountEl) {
    const mistakeCount = rawData.filter(hasMistake).length;
    listCountEl.textContent = mistakeCount;
  }
}

function setRepeatMode(enabled, options = {}) {
  const { preserveSavedLevels = false, skipSave = false } = options;
  repeatMode = enabled;
  progress.repeatMode = enabled;
  repeatToggle.classList.toggle('active', enabled);
  repeatToggle.setAttribute('aria-pressed', enabled ? "true" : "false");
  levelChips.classList.toggle('is-disabled', enabled);

  if (enabled) {
    if (!preserveSavedLevels) {
      savedLevels = [...selectedLevels];
      progress.savedLevels = savedLevels;
    }
    selectedLevels = new Set();
    LEVELS.forEach(l => setChipActive(l, false));
    updateAllChipState();
    rebuildWordPool();
    if (activeWords.length === 0) {
      showNotice("No repeat words yet.");
    }
  } else {
    const restore = Array.isArray(savedLevels) && savedLevels.length ? savedLevels : ["A1"];
    selectedLevels = new Set(restore);
    progress.levelPrefs = [...selectedLevels];
    syncChipsToSelection();
    rebuildWordPool();
  }

  if (!skipSave) saveProgress();
}

function rebuildWordPool() {
  if (!repeatMode && selectedLevels.size === 0) {
    selectedLevels.add("A1");
    setChipActive("A1", true);
    progress.levelPrefs = [...selectedLevels];
    saveProgress();
  }

  basePool = buildBasePool();
  activeWords = basePool.slice();
  updateWordCount(basePool.length);

  shuffle(activeWords);
  currentIndex = 0;

  document.getElementById('reel').innerHTML = '';
  prevUnit = null;
  activeUnit = null;

  if (activeWords.length === 0) {
    refreshActiveTranslation();
    langBtn.classList.remove('is-dim');
    return;
  }

  const first = spawnWord("pos-active");
  if (first) {
    currentIndex++;
    spawnWord("pos-next");
  }

  langBtn.classList.remove('is-dim');
  refreshActiveTranslation();
}

function onChipClick(level) {
  if (repeatMode) return;
  if (level === "ALL") {
    const allOn = LEVELS.every(l => selectedLevels.has(l));
    if (!allOn) {
      LEVELS.forEach(l => {
        selectedLevels.add(l);
        setChipActive(l, true);
      });
    } else {
      selectedLevels = new Set(["A1"]);
      LEVELS.forEach(l => setChipActive(l, l === "A1"));
    }
    updateAllChipState();
    progress.levelPrefs = [...selectedLevels];
    saveProgress();
    rebuildWordPool();
    return;
  }

  if (selectedLevels.has(level)) {
    selectedLevels.delete(level);
    setChipActive(level, false);
  } else {
    selectedLevels.add(level);
    setChipActive(level, true);
  }

  updateAllChipState();
  progress.levelPrefs = [...selectedLevels];
  saveProgress();
  rebuildWordPool();
}

levelChips.addEventListener('click', (e) => {
  const btn = e.target.closest('.chip');
  if (!btn) return;
  onChipClick(btn.dataset.level);
});

repeatToggle.addEventListener('click', () => setRepeatMode(!repeatMode));

/* =========================
   TRANSLATION SUBTITLE
   ========================= */
function ensureWordStats(item) {
  const key = getWordKey(item);
  if (!progress.stats[key]) {
    progress.stats[key] = {
      wrongStreak: 0,
      rightStreak: 0,
      wrongTotal: 0,
      rightTotal: 0,
      mastered: false,
      lastWarnedStreak: 0
    };
  }
  return progress.stats[key];
}

function updateAchievements() {
  const unlocked = progress.achievements;
  if (progress.maxStreak >= 10) unlocked.streak10 = true;
  if (progress.totals.ok >= 100) unlocked.correct100 = true;
  const masteredCount = Object.values(progress.stats).filter(s => s.mastered).length;
  if (masteredCount >= 10) unlocked.mastered10 = true;
}

function updateProgressOnAnswer(item, isRight) {
  const wordStats = ensureWordStats(item);
  if (isRight) {
    wordStats.rightTotal++;
    wordStats.rightStreak++;
    wordStats.wrongStreak = 0;
    wordStats.lastWarnedStreak = 0;
  } else {
    wordStats.wrongTotal++;
    wordStats.wrongStreak++;
    wordStats.rightStreak = 0;
  }

  if (!isRight && wordStats.wrongStreak === 5 && wordStats.lastWarnedStreak !== 5) {
    showNotice(`Be more patient: ${item.a} ${item.w}`);
    wordStats.lastWarnedStreak = 5;
  }

  if (isRight && wordStats.rightStreak === 5) {
    wordStats.mastered = true;
  }

  if (isRight) progress.totals.ok++;
  else progress.totals.bad++;

  if (stats.streak > progress.maxStreak) {
    progress.maxStreak = stats.streak;
  }

  updateAchievements();
  saveProgress();
}

function getTranslationFor(item, lang) {
  if (!item) return "";
  if (lang === "de") return "";
  return item.t?.[lang] || "";
}

function refreshActiveTranslation() {
  const lang = currentLang();
  if (!activeUnit) return;
  if (activeWords.length === 0) return;

  const data = activeWords[(currentIndex - 1) % activeWords.length];
  const sub = activeUnit.querySelector('.sub-translation');
  if (!sub) return;

  const txt = getTranslationFor(data, lang);
  sub.textContent = txt ? txt : "";
  sub.style.display = (txt && lang !== "de") ? "block" : "none";
}

/* =========================
   SLOT POSITIONING (never clip prev)
   ========================= */
function updateSlotPositions() {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const stageH = stage.clientHeight;
  const slotH = 140;

  let yNext   = Math.round(stageH * 0.06);
  let yActive = Math.round(stageH * 0.30);
  let yPrev   = Math.round(stageH * 0.62);
  let yExit   = stageH + 40;

  const maxPrev = stageH - slotH - 10;
  const minPrev = Math.max(yActive + 70, 0);

  yPrev = Math.min(yPrev, maxPrev);
  yPrev = Math.max(yPrev, minPrev);

  yActive = Math.min(yActive, Math.max(120, stageH - slotH - 60));
  yActive = Math.max(yActive, 90);

  yNext = Math.min(yNext, Math.max(18, yActive - 110));

  document.documentElement.style.setProperty('--y-next',   `${yNext}px`);
  document.documentElement.style.setProperty('--y-active', `${yActive}px`);
  document.documentElement.style.setProperty('--y-prev',   `${yPrev}px`);
  document.documentElement.style.setProperty('--y-exit',   `${yExit}px`);
}

window.addEventListener('resize', updateSlotPositions);
window.addEventListener('orientationchange', () => setTimeout(updateSlotPositions, 80));

/* =========================
   CORE GAME
   ========================= */
function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}

function findNextPlayableIndex(startIndex) {
  if (activeWords.length === 0) return -1;
  for (let i = 0; i < activeWords.length; i++) {
    const idx = (startIndex + i) % activeWords.length;
    if (!isMastered(activeWords[idx])) return idx;
  }
  return -1;
}

function spawnWord(startPos, options = {}) {
  const { forceIndex = null } = options;
  const reel = document.getElementById('reel');
  const spawnIndex = forceIndex === null ? findNextPlayableIndex(currentIndex) : forceIndex;
  if (spawnIndex === -1) return null;
  currentIndex = spawnIndex;
  const data = activeWords[currentIndex % activeWords.length];

  const unit = document.createElement('div');
  unit.className = `slot-unit ${startPos}`;
  unit.innerHTML =
    `<div class="slot-content">` +
      `<div class="caption-row">` +
        `<span class="article-reveal">${data.a}</span>` +
        `<span class="word-span">${data.w}</span>` +
      `</div>` +
      `<div class="sub-translation"></div>` +
    `</div>`;

  reel.appendChild(unit);

  if (startPos === "pos-active") {
    activeUnit = unit;
    refreshActiveTranslation();
  } else {
    const sub = unit.querySelector('.sub-translation');
    if (sub) sub.style.display = "none";
  }

  return unit;
}

function handleChoice(choice) {
  if (isLock || activeWords.length === 0 || !activeUnit) return;

  langBtn.classList.add('is-dim');

  const currentData = activeWords[(currentIndex - 1) % activeWords.length];
  const correctArt = currentData.a;
  const isRight = choice === correctArt;

  if (!isRight) {
    activeUnit.classList.add('shake-active');
    setTimeout(() => activeUnit.classList.remove('shake-active'), 300);
    stats.bad++;
    stats.streak = 0;
    updateScore();
    updateProgressOnAnswer(currentData, false);
    return;
  }

  isLock = true;
  stats.ok++;
  stats.streak++;
  updateScore();
  updateProgressOnAnswer(currentData, true);

  activeUnit.classList.add('resolved');
  activeUnit.style.color = `var(--${correctArt})`;

  setTimeout(() => {
    const nextInLine = document.querySelector('.pos-next');

    if (prevUnit) {
      prevUnit.className = 'slot-unit pos-exit';
      const toDelete = prevUnit;
      setTimeout(() => toDelete.remove(), 700);
    }

    prevUnit = activeUnit;
    prevUnit.className = 'slot-unit pos-prev resolved';

    activeUnit = nextInLine;
    if (activeUnit) activeUnit.className = 'slot-unit pos-active';

    currentIndex++;
    spawnWord("pos-next");

    basePool = buildBasePool();
    updateWordCount(basePool.length);

    refreshActiveTranslation();
    isLock = false;
  }, 900);
}

function updateScore() {
  document.getElementById('scoreOk').innerText = stats.ok;
  document.getElementById('scoreBad').innerText = stats.bad;
  document.getElementById('streak').innerText = stats.streak;
}

const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const WORD_INDEX = new Map(rawData.map(item => [getWordKey(item), item]));

function clearSearchResults() {
  searchResults.innerHTML = '';
  searchResults.classList.remove('is-visible');
}

function renderSearchResults(items) {
  searchResults.innerHTML = '';
  if (items.length === 0) {
    searchResults.classList.remove('is-visible');
    return;
  }

  items.forEach(item => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'search-item';
    btn.dataset.key = getWordKey(item);
    btn.innerHTML = `<strong>${item.a}</strong> ${item.w} <span class="hint">${item.l}</span>`;
    searchResults.appendChild(btn);
  });

  searchResults.classList.add('is-visible');
}

function updateSearchResults() {
  const q = searchInput.value.trim().toLowerCase();
  if (!q) {
    clearSearchResults();
    return;
  }
  const matches = [];
  for (const item of rawData) {
    if (item.w.toLowerCase().startsWith(q)) {
      matches.push(item);
      if (matches.length >= 8) break;
    }
  }
  renderSearchResults(matches);
}

function jumpToWord(item) {
  const pool = buildBasePool();
  const key = getWordKey(item);
  const rest = pool.filter(w => getWordKey(w) !== key);
  shuffle(rest);

  basePool = pool;
  activeWords = [item, ...rest];
  updateWordCount(basePool.length);

  currentIndex = 0;
  document.getElementById('reel').innerHTML = '';
  prevUnit = null;
  activeUnit = null;

  const first = spawnWord("pos-active", { forceIndex: 0 });
  if (first) {
    currentIndex++;
    spawnWord("pos-next");
  }

  langBtn.classList.remove('is-dim');
  refreshActiveTranslation();
}

searchInput.addEventListener('input', updateSearchResults);
searchInput.addEventListener('focus', updateSearchResults);
searchInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const first = searchResults.querySelector('.search-item');
    if (first) {
      const item = WORD_INDEX.get(first.dataset.key);
      if (item) jumpToWord(item);
    }
    clearSearchResults();
  }
});

searchResults.addEventListener('click', (e) => {
  const btn = e.target.closest('.search-item');
  if (!btn) return;
  const item = WORD_INDEX.get(btn.dataset.key);
  if (!item) return;
  searchInput.value = item.w;
  clearSearchResults();
  jumpToWord(item);
});

document.addEventListener('click', (e) => {
  if (e.target === searchInput || searchResults.contains(e.target)) return;
  clearSearchResults();
});

window.onkeydown = (e) => {
  const tag = document.activeElement?.tagName || "";
  if (tag === "INPUT" || tag === "TEXTAREA") return;
  const key = e.key.toLowerCase();
  if (key === 'a') handleChoice('der');
  if (key === 's') handleChoice('die');
  if (key === 'd') handleChoice('das');
};

setLangIndex(0);
syncChipsToSelection();
if (repeatMode) {
  setRepeatMode(true, { preserveSavedLevels: true, skipSave: true });
} else {
  rebuildWordPool();
}
updateSlotPositions();
updateScore();
</script>
</body>
</html>
